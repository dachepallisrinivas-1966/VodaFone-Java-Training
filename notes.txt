D.Srinivas
I am a Corporate Trainer
Having 32+ years of expercience
10 years of corporate training experience
My major clients - CapGemini, Cognizant, HP, Infosys, Samsung, MPhasis, CMS etc.,
Java Training (Full Stack Trainings)
dachepallisrinivas@gmail.com
630 573 0633
I am from visakhapatnam, Andhra Pradesh.
_________________________________________________________________________________________________________________________________________


							Day-1
						------------------------



 Java Introduction
 JDK, JRE, JVM, JIT, Byte Code
 Why Java Platform Independent (WORA)
 OOP with Java
 Class, Objects and Methods
 Constructor
 Method Overloading
 Constructor Overloading
 Static  & Final Keywords
 Inheritance
 Method Overriding
 Use of super keyword
 Compare Overloading and Overriding
 Wrapper Class
 Arrays in Java
 Garbage Collector
 Finalize Method
 Program Example using Eclipse



Lab Setup:
---------------
1. Java 8 is required
2. Eclipse IDE Enterprise Edition 

								Core Java
							----------------------------
What is Java?
	It is strictly, but partially an object oriented programming language.


primitive datatypes:
	int, float, char, double, byte, short, long		-	 not objects


who developed Java?
	James Gosling from Sun microsystems in 1992.
	Oracle corporation purchased Sun microsystems.
	(www.oracle.com)

Java editions:
	1) Java SE	(Standard Edition)			-	Console/Desktop/StandAlone Apps
	2) Java EE	(Enterprise Edition)			-	Web Applications / Distributed Applications
	3) Java ME	(Micro Edition)				-	Mobile Apps	-	Not offered by oracle corp. any more.


JDK (Java Development Kit)	- 	used by developers
	

	LTS (Long Term Support)
		Java 8
		Java 11
		Java 17
		Java 21

JRE (Java Runtime Environment)
	It is installed automatically along with JDK.


JVM (Java Virtual Machine)
	It is a memory in JRE, created everytime we run a java program.
	once the program is terminated, JVM also destroyed.


What is JDK vs JRE vs JVM?

	JDK = JRE + development tools like javac, java etc.,
	JRE = JVM + libraries


WORA ?
	Write Once Run Anywhere
	This is possible because Java is a platform independent language.	
	

JIT (Just Intime) compiler:
	it is used to compile repetetive code in their nature.
	It is also part of JRE.



Structure of a Java Program:
------------------------------
	[Documentation Section]
	[Package Statement]
	[Import Statements]
	[Interface Statements]
	
	class ClassName {
		public static void main(String[] args) {
			// your code goes here ....
		}
	}
	

write a java program to print "Hello World".

steps:
-------
1. goto cmd prompt.
2.  
	> notepad Hello.java

3. type the following program

	class Hello {
		public static void main(String[] args) {
			System.out.println("Welcome to the Training Program for Vodafone");
		}
	}

4. save the program.

5. compile the program.

	> javac Hello.java

6. verify what are files created.	(not mandatory step)

	> dir Hello.*

03-10-2023  11:48               448 Hello.class
03-10-2023  11:48               134 Hello.java

7. execute the program

	> java Hello
	
8. observe the output.
	
	Welcome to the Training Program for Vodafone

	



Java Tokens:
------------------
	Token means an atomic item in a program.

	a) Identifiers	:	name given to variables, class, data members, methods, interface etc.,
	b) keywords	:	around 50 keywords	(eg: if, for, switch, while, int, float etc.,)
	c) operators	:	
		1) arithmetic
		2) relational 
		3) logical
		4) conditional
		5) increment/decrement
		6) arithmetic assignment (shorthand)
		
	d) comments	:	ignored by the compiler.
				a) //		end-of-line comment	 	(single line comment)	
				b) /* and */	block comment			(multi-line comment)				
				c) /**	and	*/				documentation comment

	e) literals		: any hard-coded values		(eg: 2, -3, 5.6)


Naming Conventions:
--------------------

	1) Idenitifiers given to variables, objects, methods:	(camel notation)
		a) it should start and continue in lowercase.
		b) if it has more than one word, it follow initcap (first letter is in capital and rest in small).
	
		eg:	length
			lengthOfBox
			boxLength
			lengthInMeters

			showData()
			toString()
			mapReducer()

	2) Identifiers given to user-defined datatypes like 		(pascal notation)
		class, interface, enum etc.,

		a) follow initcaps all through.

			String
			InputStream
			ArrayIndexOutOfBoundsException
			IOException

			
	3) Identifiers given to constants

		a) constant is a name given to literal.

		b) all are in upper case.
		    if more than one word, use underscores between them.

		    eg: PI, MIN_VALUE, MAX_VALUE

	4) Identifiers given to packages.

		a) all are in lowercase
		b) they are often abbreviated


		eg:	io,  util, awt, lang

Operators:
	
	arithmetic operators		+, -, *, /, %
	relational operators		>,<,>=,<=,==,!=
	logical operators		&&	||	!
	increment/decrement	++	--
	assignment operators	=	+=	-=	*=	/=	%=
	conditional operator		(condition)?st-1:st-2
	miscellaneous operators	.	(member access operators)
				()
				[ ]	{ }	<>	
				"instance of"


Literals that are supported by Java:
------------------------------------------------------
	Integer 	decimal		7	
			binary		0b100
			octal		07	
			hexadecimal	0x7
	
	Floating-Point	3.14	-2.6	3.0

	Boolean		true, false

	Void		null

	Character	'A', '@', '7'

	string		"impulse", "49-53-20/25", "9247175823", "A"



Language Fundamentals:
------------------------------------
datatypes:
-------------
1) primitive datatypes 	(pre-defined / intrinsic / fundamental)
	numeric
		byte		1		-128 to 127
		short		2		-32768 to 32767
		int		4		-2^31 to 2^31-1
		long		8		-2^63 to 2^63-1

		float		4		single precision		(scientific / mathematical applications)
		double		8		double precision		(commercial applications)

	non-numeric
		char		2
		void		--
		boolean		indefinite or system independent
				


2) user-defined datatypes
	class		interface	
	abstract class	



								Eclipse IDE
							-----------------------------
1. create a new folder in any of your driver (not in C drive) "vodafone".
2. click on Eclipse IDE icon 
	workspace : d:\vodafone\CoreJavaWorkspace
	click "Next"
3. click "Create a Project" link on the left side menu of IDE.
   choose "java project" option

	Project : ToStartWith
	Choose your java environment : Java-11
	uncheck "Module-Info"
	click "Next"

	you can observe "src", "bin" folder related information.

	click "Finish"
4) click "ToStartWith" in "package explorer" window
	we will see "src" folder.
	right click "src" folder -> New -> class
		class name : Hello
		check "public static void main(String[] args)
	click "Finish"
5) type the program.

	public class Hello {
		public static void main(String[] args) {
			System.out.println("welcome to vodafone training");		// only line you have to type

		}
	}
6) right click inside the program -> Run as -> Java Application

	on the console window, we can see the output.
		welcome to vodafone training

	

______________________________________________________________________________________________________
Note:
	"bin" folder is the location where eclipse store all ".class" files.
_______________________________________________________________________________________________________

_________________________________________________________________________________________________________
Note:
	if no package is created, all our java programs are stored under an virtual pacage whose name is
	"default package".
__________________________________________________________________________________________________________


What is a package?
	a package is collection of related java classes, interfaces, sub packages.
	the package structure will resolve the name conflicts.
	it is represented as a folder in o/s.

How do you name packages?
	
	com.vodafone.ui	:	to store all you main programs.
	
	
src -> new -> package
	package name : com.vodafone.ui
	click "Finish"


----------------------------------------------------------------------------------------

How do you accept data into variables during program execution?

	Scanner:
	--------
		It is a pre-defined in java, using which we can accept data.
		It is available in java.util package.

		in order to use this class, we must import it.

		import java.util.Scanner;


		methods:
		--------
			i) 	nextInt()	
			ii)	nextDouble()
			iii)	next()
			iv) 	nextLine()

		1. we must create object for the Scanner class.

			Scanner scan = new Scanner(System.in);

			System.in refer to standard input device i.e., keyboard

		2. use relevant methods to accept data.

			int number = scan.nextInt();
			double weight = scan.nextDouble();
			String name = scan.nextLine();

	_________________________________________________________________________________________________
	Note:
		Scanner is also known as resource.
		whenever memory is allocated for a resource, we must de-allocate it by closing resource.

		scan.close();
	_________________________________________________________________________________________________


write a java program to find the simple interest when principle, time and rate are given by the user.

	

									OOPS
					   		(Object Oriented Programming System)
					---------------------------------------------------------------------

It is a programming paradigm.
	a) monolithic
	b) procedure oriented
	c) structured
	d) object oriented

advantages of OOP:
	1) code reusability
	2) security

class:
	it is a user-defined datatype which represent an entity in terms of properties and behaviours.
	it is a reusable software component.
	properties are also known as data members.
	behaviours are represented as methods (functions).
	no memory is allocated when we define the class.

	classes are also called as POJO (Plain Old Java Object), Model, Bean etc.,
	As of now, we use classes to represent data and hence they are often treated as Models.

	syntax:
		class ClassName {

			// properties go here
		}
	

object:
	it is a variable whose datatype is a class.
	memory is allocated only when we create an object.


	syntax:
		ClassName  objectName;

		objectName = new ClassName();

	______________________________________________________________________________________________________________

	Note:
		the "new" keyword allocate memory for the object.
		whenever a "new" keyword is used, it represent dynamic memory.
	______________________________________________________________________________________________________________


	
features of OOP:
-----------------
	data hiding:
		prevent the direct access of data members from outside the class.
		we can achieve data hiding by making all data members are private.

	encapsulation:
		using this feature, we can access the private data members of a class
		by means of public setter and getter methods.



				
	inheritance
	abstraction
	polymorphism


access specifiers (access modifiers) (security constraints):
-------------------------------------------------------------
	i) 	default : here "default" is not a keyword.
	     (friendly)	  if no access is specified, it takes default access.
			  members under this access, can be used in the current class as well as any other class
			  inside the same package.

	i) 	private	: members under this access, can be used only in the class in which they are declared.
	ii) 	public	: members under this access, can be used in any class in that project.	
	iii) protected	: members under this access, can be used either in the current class or from any of 
			  the sub class.


method overloading:
--------------------
	it refers to multiple methods (functions) having the same name but with different parameter list.
	it is known as "method overloading".

	class Geometry {

		/* method overloading */
		public int area(int length, int breadth) {
			return length * breadth;
		}
		/* method overloading */
		public int area(int radius) {
			return 3.14 * radius * radius;
		}

	}


constructors:
--------------
	it is a special method that is executed automatically whenever an object is created.
	it should have same name as that of class.
	it can have parameters.
	it cannot return any value and should not have return type such "void".
	a class can have many constructors.this feature is known as "Constructor overloading".	

	it is used to initialize data members of a class.

"this" reference:
-----------------
	represent current object.

static members:
------------------
	"static" means "sharable".

	1) static data members:
		these are special data members which have only one memory location, data in which is shared 
		across all objects of the class.


	2) static methods:
		these are special methods and they can be called directly with the class name.
		we need not have any object to utitlize these methods.
	
		static methods are used mainly to manage static data members.
	
		syntax:
		-------
				ClassName.statMethodName(arg-1, arg-2, ....);	
	


======================
Day-2	(4-Oct-2023)
======================

							Inheritance
						------------------------------
It is the process of creating a new class (sub class) from an existing class (super).
sub class can access all the public features of super class as well as any extra features that are added to it.
it is mainly for "code reusability".
it also represent an "is-A" relationship.
"extends" keyword must be used to create sub class.
syntax:
-------
	class  SubClass  extends SuperClass {

	}

types of inheritance:
-------------------------
1) simple (single) inheritance		(A -> B)
2) hierarchical 			(A -> B, A -> C)
3) multi-level				(A -> B -> C)

____________________________________________________________________
Note:
	multiple inheritance is not supported on classes in java.
	to achieve this, we have to use interfaces.
____________________________________________________________________


"super" keyword:
-------------------
1. we can access super class public varibales
2. we can call super class constructors in sub class constructor.
	a) super()			: to call super class default constructor
	b) super(arg-1, arg-2, ...)	: to call super class parameter constructors

	_________________________________________________________________________________________
	Note:
		if we want to call the super class constructor in a sub class constructor,
		it must be written as first statement in the constructor code block.
	_________________________________________________________________________________________

3. we can call super class methods in sub class method.
	c) super.method(arg-1, arg-2, ...);



method overriding:
-------------------
when a sub class contain a method that has same signature as that of another method in it's super class,
then the sub class method is said to be "overriding".
we can use "@Override" annotation for compile-time check. It is not mandatory, but recommended.

simple (single) inheritance:
-----------------------------


							Person (name, age)
								|
								↓ extends
							Employee (salary)

hierarchical inheritance:
--------------------------

							Person (name, age)
								|
								↓ extends
						-----------------------------------------	
						↓					↓
					Employee (salary)			Student (fee)


multi-level inheritance:
---------------------------

							Person (name, age)
								↓					
							Employee (salary)			
								↓
							Manager (bonus)


_____________________________________________________________________________________________________________
Task:
			class Manager extends Employee {

					// code

			}

			modify the InheritanceApp.java
			add the manager object and print it.
_____________________________________________________________________________________________________________


final keyword:
--------------
	it can be used in 3 ways.

	a) final variable:
		it is used to declare constants.
		constant is a name given to literal.

		eg:
			final int PASS_MARKS = 35;

		____________________________________________________________________________________
		Note:
			Generally constants are declared with public static final keywords.
		eg:
			public static final int PASS_MARKS = 35;
		_____________________________________________________________________________________


		
	b) final method:
		if a method is final, it cannot be overridden in sub classes.
		
	c) final class:
		if a class is final, it cannot be inherited any more.


Wrapper class:
--------------
	every primitive data type has a corresponding pre-defined class.

	primitive 	wrapper class
	-----------	-------------
	int		Integer 
	double		Double
	long		Long
	boolean		Boolean
	short		Short
	byte		Byte


Arrays:
--------
	In java, an array is also an object.
	While creating an array itself, we must mention the size.
	Once it is declared, we can't change the size.
	index based operations are possible.

	Every array contain a property "length", that return no. of cells in the array.
	
	syntax:
		int[] arr = new int[5];

	_________________________________________________________________
	Note:
		to store large amount of data
	_________________________________________________________________

	
Enhanced for:	(JDK 1.5)
-------------
	using this loop, we can iterate over arrays and collections.

	syntax:
	-------
		for(datatype  var : array) {
			// code
		}
	
	__________________________________________________________________________________________________________
	Note:
		Enhanced for loop always process from the first element till the last element in forward-only
		direction.
	__________________________________________________________________________________________________________


Garbage collector:
-----------------
	It is a program in JRE, will peridocially check memory, and remove any unused (unreferenced) objects 		
	and reclaim the memory.

finalize() method:
-------------------
	it is available in java.lang.Object class.
	we can override this method in any of the program, and you can request the garbage collector to
	cleanup the memory.

				System.gc();



    • Abstract Class 
    • Interface (Normal, Functional, Marker) 
    • Lambda Expressions 		
    • Interface default and static Methods 	(JDK 8+)
    • Package 
    • Access Specifier 
    • Exception Handling Introduction 
    • Exceptions Vs Errors 
    • Checked Exceptions vs Unchecked Exceptions 
    • Create and Use Custom Exception 
    • Introduction to Generic 
    • Collections Framework Introduction 
    • List Interfaces and ArrayList, LinkedList, Vector 
    • Set Interface and HashSet, LinkedHashSet, TreeSet 
    • Map Interface and Hashmap, TreeMap 
    • Queue Interface 
    • Comparators/Comparable interfaces 



Abstract class:
---------------
	"absract" means "incomplete".

	"abstraction" means show the behaviour but hide the implementation details.

	if a class is defined with an "abstract" keyword is known as "abstract class".
	for an abstract class we cannot create object for it.

	____________________________________________________________________________
	Note:
		if we try to create object for an abstract class, compiler will show 
		the following message ....

			"Cannot instantiate" the type ClassName
	____________________________________________________________________________


abstract methods:
------------------
	it is a method declaration without any definition.
	when a class contain atleast one abstract method, then the class should be defined as "abstract class".
	
	______________________________________________________________________________________
	Note:
		An abstract method can exist only in an abstract class.
		But vice versa may not be true.
	_______________________________________________________________________________________



	__________________________________________________________________________________________________
	Note:
		in order to make use of any abstract class, we have to create a sub class and override
		all abstract methods of the super class, then create object for the sub class and use it. 
	___________________________________________________________________________________________________



polymorphism:
-------------
	exhibiting different behaviours for a same method call.

	_______________________________________________________________________________
	Note:
		create a super class reference variable.
		store sub class objects in it.
		call the polymorphic method using the super class reference variable.
	_______________________________________________________________________________
	

								

								Interface
							-----------------------------
An interface is also a user-defined datatype.
it contain only public abstract methods and public static final variables.	(upto JDK 7).
it cannot have properties.


we can't create object for an interface.
to make use of this, we have to create a sub class (implementation class) using "implements" keyword.
override all abstract methods of the interface in it.
then create object for the sub class.


	______________________________________________________________________________________
	What is difference between abstract class and interface?

		1. abstract class can have properties, fully defined methods, constructors,
		   abstract methods.
		
		   an interface can contain only abstract methods and final variables.

		2. using interfaces, we can achieve multiple inheritance. 
	______________________________________________________________________________________


Functional Interface:
	it is an interface that contain only one abstract method.
	it can be marked with @FunctionalInterface annotation.

	it is mainly for lambda expressions.


Default method & Static method:
	from jdk 8 onwards, we can write method definitions inside an interface.
	but the method must be default or static.

	these are mainly given for backward compatibility.

Lambda:
	it is a short way of working with functional interfaces.



								Exception Handling
							----------------------------------------

	An exception is an unexpected event due to which the program is terminated.

errors are classified into
	syntax errors	(detected by the compiler)
	logical errros	(detected by unit testing)  
	resource errors	(system errors)
	exceptions	(run time errors)

whenever an exception occurred, the program is aborted. 
to handle exceptions, java provide try and catch.

try {
	code that is expected to raise an exception
} catch(ExceptionType-1  exceptionObject) {
	exception handler task
} catch(ExceptionType-2  exceptionObject) {
	exception handler task
} ....
finally {
	task that should be executed for sure
}

the program will never terminate without executing finally block.



					Exception API	(java.lang)
				-----------------------------------
					
					Throwable (i)
				       	     ↓
		-------------------------------------------------
		↓						↓
	     Error (c)					   Exception (c)
								↓
						---------------------------------
						↓				↓                                                                                   
					RunTimeException		<<checked Exceptions>>
						↓
					<<unchecked exceptions>>

ArrayIndexOutOfBoundsException
StringIndexOutOfBoundsException
InputMismatchException
NullPointerException
etc.,

java.lang.Exception class
----------------------------------
	Exception()
	Exception(String msg)

	String getMessage()
	void printStackTrace()
	

All exception related classes are derived from Exception class or RunTimeException class.


Checked and Unchecked Exceptions:
------------------------------------------------
checked exceptions are informed by the compiler. they cannot be avoided. we must handle these exceptions using try and catch.

unchecked exceptions are not informed by the compiler. we should not use try and catch to handle these exceptions.
They should be  avoided by means of "Defensive Programming". 

Compiler identify checked exceptions. It will not allow you to continue if we don't handle it.
In case of unchecked exceptions, the compiler will not force programmer to handle it.

How does the compiler know whether it is checked or unchecked?
--------------------------------------------------------------------------------------
Any class derived from "RunTimeException" class are "unchecked exceptions", Otherwise they are  "checked exceptions".


JDK 7 Enhancements:
---------------------------------
a) multi-catch exception

try {
	code
} catch (Exception-1	   |   Exception-2  |  Exception-3    obj) {
	statements
}

b) try-with-resources



Custom Exception (user-defined exception):	
------------------------------------------
1) Create your own exception class which must be inherited from java.lang.Exception class.
2) Write a constructor that takes a String parameter and pass this String to the super class constructor.


how do we raise a user-defined exception?
-------------------------------------------------------
we use "throw" keyword to raise a user-defined exception.

syntax:
	throw new ExceptionClass(arg-1);




						Collections Framework
						  (Collections API)
						     (java.util)
					---------------------------------------
API stands for "Application Program Interface".
Any API is a collection of interfaces and abstract classes.
we need to have an implementation for any API in order to work with.

for collections api, java itself provide implementations also. 
so, we need not depend on any third party libraries.
that is why collections is known as framework.

https://docs.oracle.com/javase/tutorial/collections/index.html


1) interfaces
2) implementations
3) algorithms
4) aggregate operations


Collections are used to store and manage "group of objects".

_____________________________________________________________
Note:
	we cannot use primitive datatypes with collections.
_____________________________________________________________

Collection interface methods:
-----------------------------
	boolean add(E)
	boolean addAll(C)
	void clear()
	boolean contains(O)
	boolean contains(C)
	boolean isEmpty()
	boolean remove(O)
	boolean removeAll(C)
	int size()
	Object[] toArray()

there are 2 types.
-------------------
1) raw collection			(heterogenous)				- not recommended
2) generic collection			(homogeneous and typesafe)		- recommended		

what is generic?
	it allow type-safety.
	it is represented within angle brackets  <Type>.
	we use generics in conjunction with collections.

List interface:
---------------
	1. it allow duplicate objects.
	2. it support index-based operations.
	3. it allow null also.


	implementation classes:
	-----------------------
	ArrayList			
	LinkedList
	
	ArrayList:
	-----------
		it is used when we want to perform traversal operations frequently.
		it is not good to perform insert/delete/modify operations.

		methods:
		--------
		get(index)
		set(index, new_value)
		add(index, element)
		indexOf(element)
		remove(index)


		iterator()

	LinkedList:
	------------
		it is good to perform insert/delete/modify operations.

	

	iterator() : return an Iterator object, using which we can iterate over a collection.
		     this method available for List interface.
	
	Iterator is an interface (java.util).
		a) hasNext()
		b) next()



Set interface:
-----------------
	it doesnot allow duplicates.
	it will not support index based operations.
	it allow null values.

	__________________________________________________________________________
	Note:
		In a TreeSet, we cannot insert null values.
		If you do so, it will throw NullPointerException.
	__________________________________________________________________________


	implementation classes:
	-----------------------
	HashSet		:	order of retreival is not guaranteed.
	LinkedHashSet	:	insertion order	
	TreeSet		:	sorted order


___________________________________________________________________________
Task:
	Vector Program
	Queue Program
___________________________________________________________________________


Map interface:
---------------
	it is used to store key-value pair kind of data.
	key cannot be duplicated.
	key cannot be null.
	value be can be duplicated.
	value can be null.


	implementation classes:
	-----------------------
	HashMap		:	order of retrieval is not guaranteed.	
	LinkedHashMap	:	insertion order
	TreeMap		:	sorted order on key

	methods:
	--------
		put(key,value)
		value get(key)
		boolean containsKey(key)
		Set<K> keySet()
		values()


Collections class	(java.util):
--------------------------------------
	sort(list)
	reverse(list)
	binarySearch(key, list)


Comparable interface:
------------------------

	java.lang.Comparable


	int compareTo(Object o)

		return 0 of two objects are equal.
		return +ve integer if first object is big.
		return -ve integer if first object is small.



==========================
Day-3	(4-Oct-2023)
==========================	


	Iterator:
		it is an interface using which we can iterate over a collection.

		hasNext()	:	return true if any elements are available for iteration.
					return false if all items are over during iteration.

		next()		:	return the next element from the iterator

		we have to obtain the iterator from the list.

		ArrayList<Integer> list = new ArrayList<>();

		...
		Iterator<Integer>  it = list.iterator();		// to obtain the iterator

		while ( it.hasNext() ) {
			Integer data = it.next()
			System.out.println(data);
		}


    Comparator interface (Functional Interface):

		java.util.Comparator

		It is also meant for sorting.

		we can create a new class that is implementing Comparator interface.
		it has one abstract method ...
			int compare(Object first, Object second)


	___________________________________________________________________________
	Task:
		what is the difference between Comparable and Compartor?
	___________________________________________________________________________



    • Introduction to Web Application
    • URL, URI 
    • http protocol 
    • Request and Response Mechanism 
    • Servlet Introduction 
    • Building Jar and War Files 
    • 3 Tier Architecture 
    • Create Maven Project 
    • Working with POM 
    • Add dependent Library 


Java EE (Enterprise Edition):
--------------------------------
	Enterprise is the one who provide services across the globe.
	It is not specific one geographic location.
	For these people, we must develop "Distributed Applications".

	Some part is executed in server. Other part is executed in client.
	Java EE provide us to develop client-server based distributed applications.
	Most common type of distributed application is "Dynamic Web Applications".

	Static Web Application:
		designer provide static web pages, every user who is watching the web site  will get the same content.
		eg: w3schools.com, wikipedia etc.,

	Dynamic Web Application:
		content gets created on the fly.		
		we will have a server program. which generate HTML pages dynamically.
		content is displayed based on the user who logged in.

		eg: gmail, onlinesbi

	What is URL?
	------------
		It stands for Uniform Resource Locator.
		It will bring a web page to the client (end user)

		eg: https://www.w3schools.com

	What is URI?
	------------
		It stands for Uniform Resource Identifier.
		URI is string of characters that generally indentifies any web resource by using
		a name, a location or both.

		
	what is a protocol?
	-------------------
		protocol is a set of rules.	
		a protocol helps to establish data exchange and communication between two systems.

		TCP/IP : standard protocol to exchange data between two machines connected in a network.


	what is internet?
	-----------------
		network of networks.
		
		http	(hyper text transfer protocol)
		https	(hyper text transfer protocol secured)

		these protocols run over TCP/IP.

	how does a url looks like?
	---------------------------
		protocol : port // ServerDomainName
		protocol : port // ServerIpAddress
		protocol : port // Resource

	
	

	Web Client	:	Browser	
				eg: Chrome, Edge, FireFox, Brave, Safari, Opera	etc.,

	Web Server	:	It is a software that can host (deploy) a website.
				eg: Apache Tomcat, Resin etc.,

	Application Server :	It can host web applications as well as other distributed resources.
				eg: Wildfly	(JBoss)
				    GlassFish	(Oracle Corp.)
				    Web Sphere	(IBM)
				    Web Logic

	
	port:		It is a memory location	where a server will wait for a request.
			every server software run on a specific port.
			Apache Tomcat by default run on port 8080.


			But if the port is alreqady occupied by any other softwares, we need to change 
			the port number.


			But to check whether you tomcat is running or not, open the browser and type 
			the following url ...


				http://localhost:8080


			if tomcat runs properly, we could see the home page of apache tomcat.

			if not, we get 404 error.	(404 - resource not found)
		
			404 is one of the popular Http Status Code.


	Server Side Programming:
			
			Java		Servlet/JSP/Spring Web etc.,
			.Net		ASP.Net/ ASP.Net MVC etc.,
			Python		DJango Framework etc.,


	Request		:	client always give a request to the server.
				(HttpRequest)
				
	Response	:	server always send response to the client
				(HttpResponse)

		Request - Response Cycle	(Request - Response Mechanism)


	Web Server : Contain Web Container or Servlet Container

			Java		Apache Tomcat
			.Net		IIS (Inter Information Server - Microsoft)
			Python		Apache Web Server



	Http Request Methods:
		
			GET	:	when the client want to GET any information from the server.
					(Default)


					eg: if client click a link

					eg: if he type a url


			POST	:	when the client want to POST any data to the server.


	Difference between GET and POST?


		https://www.google.com/search?q=java+programming+tutorial

		GET is not secured	(data is exposed in the url)
		We can pass limited amount of data uasually 2 KB. (header)

		POST is secured
		we can pass large amount of data.  (body)


	How to download Tomcat?

		https://tomcat.apache.org/download-90.cgi

		choose "64-bit windows zip" 



		folders:
			*** 1) bin		:	startup.bat		shutdown.bat
			*** 2) conf		: 	contain configuration files.

							server.xml

			*** 3) lib
			4) logs	
			5) temp
			*** 6) webapps
			7) work


		how do you check?

			go to the tomcat software location in the windows explorer.
			go to the "bin" folder.
			at the command prompt, type "startup"


			open the browser and type the url ...
				localhost:8080

			you should see "tomcat" home page.

		how do you stop the server?

			come back to command prompt window.
			type "shutdown"


	
	http://localhost:8080/ServletDemo/
		equivalent to
	http://localhost:8080/ServletDemo/index.html


	http://localhost:8080/ServletDemo/hello


	HelloServlet.java
	------------------


package com.vodafone.servlet;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

/**
 * Servlet implementation class HelloServlet
 */
@WebServlet(description = "just to say hello to everyone", urlPatterns = { "/hello" })
public class HelloServlet extends HttpServlet {
	private static final long serialVersionUID = 1L;

	/**
	 * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		PrintWriter  out = response.getWriter();
		out.println("<h3>Hello User, Welcome to the App</h3>");
	}

	/**
	 * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)
	 */
	protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		doGet(request, response);
	}

}


                                   			 3-Tier Architecture
                                		-----------------------------------
    
Presentation tier: (Presentation Layer)
    This is the first and topmost layer which is present in the application. 
    This tier provides presentation services, that is presentation, of content to the end user through CUI / GUI. 
    This tier can be accessed through any type of client device like desktop, laptop, tablet, mobile, thin client, and so on. 
    
Application tier (Business Logic Layer): 
    This is the middle tier of this architecture. 
    This is the tier in which the business logic of the application runs. 
    Business logic is the set of rules that are required for running the application as per the guidelines laid down by the organization. 
    
Data tier: (Data Layer)
    This is the lowest tier of this architecture and is mainly concerned with the storage and retrieval of application data. 
    The application data is typically stored in a database server.

Benifits:
	Faster development: 
		Because each tier can be developed simultaneously by different teams, an organization can bring the application to market 		faster, and programmers can use the latest and best languages and tools for each tier.

	Improved scalability: 
		Any tier can be scaled independently of the others as needed.

	Improved reliability: 
		An outage in one tier is less likely to impact the availability or performance of the other tiers.

	Improved security: 
		Because the presentation tier and data tier can't communicate directly, a well-designed application tier can function as a 		sort of internal firewall, preventing SQL injections and other malicious exploits.




						3-Tier application in web development
					-------------------------------------------------------
				
	In web development, the tiers have different names but perform similar functions:

	The "web server" is the presentation tier and provides the user interface. This is usually a web page or web site, such as an 	ecommerce site where the user adds products to the shopping cart, adds payment details or creates an account. The content can be 	static or dynamic, and is usually developed using HTML, CSS and Javascript.

	The "application server" corresponds to the middle tier, housing the business logic used to process user inputs. To continue the e	ecommerce example, this is the tier that queries the inventory database to return product availability, or adds details to a 	customer's profile. This layer often developed using Python, Ruby or PHP and runs a framework such as e Django, Rails, Symphony or 	ASP.NET, for example.
	
	The "database server" is the data or backend tier of a web application. It runs on database management software, such as MySQL, 	Oracle, DB2 or PostgreSQL, for example.


	Contract between equals() and hashcode():
	--------------------------------------------
	if two objects are equal as a result of equals(), then they should have the same hash code.
	but vice versa is not required.



========================
Day-4	(6-Oct-2023)
========================

    • Log File Handling (Log4j) 
    • Best Practices in Java Coding 
    • Debugging in Eclipse 
    • Design Pattern Introduction 

    • JDBC Introduction 
    • Connect with MySQL Database 
    • Statement / Prepared Statement / Result Set 
    • CRUD Operation using JDBC 
    
    • MVC Architecture 
    • Basic of Spring Boot framework using Maven 




	jar	:	java archive file
			you will create a jar fle and distribute it.

			Any java libraries are supplied in the form of ".jar" files.
			it contain ".class" files.

		
	war	:	web archive file
			you will create a war file and deploy that file into 
			tomcat server if it is a web application.
	

			web admins will do the deployment.

Maven:
------

	Apache Maven is a software project management and comprehension tool. 
	Based on the concept of a project object model (POM), Maven can manage a project's build, reporting and documentation 
	from a central piece of information.


	How to create a maven project in eclipse?
	------------------------------------------
		a) you can create console applications
		b) you can also create web applications.


	File -> New -> Other -> Maven -> Maven Project

		check "Create Simple Project" checkbox
		click "Next"
	
		group id:	com.vodafone			(package name)
		artifact id:	sample-maven-project		(project name)
		packaging:	jar


	
	maven simple project folder structure:
	--------------------------------------
		src/main/java		:	where we write java programs
		src/main/resources	:	where we put all non-java programs
						like property files etc.,
		src/test/java		:	all your testing code
		src/test/resources	:	all non-java programs required to perform testing

	pom.xml
	-------
		pom stands for "project object model".
		xml files are mainly used to store configuration information.

		dependencies : 
			libraries that are required to execute the project.

		in pom.xml, we have to add the necessary dependencies.

	_____________________________________________________________________________________________
	Note:
		By default, maven simple project comes with J2SE-1.5.
		This is ok to execute project in your machine.

		But for build any project, it needs java 7 or later.
	_____________________________________________________________________________________________

	
								
								Logging
							---------------------------

	Log4j:
		log4j stands for "logging for java".
		Log4j is a simple, flexible and fast java based logging framework. 
		

	Log4j components:
		a) Logger	: It is used to log the messages.

		b) Appender	: It is used to publish the logging information to the destination like console, 
				  file, database etc.

		c) Layout	: It is used to format logging information in different styles.


	Advantages of Log4j:
		It provides the easy maintenance and fast debugging.

	Disadvantages of Log4j:
		It slow down the application.



	Logger class:
		Logger class provides the methods for logging process. 
		We can use the getLogger() method to get the Logger object.

		Syntax:			
			public static Logger getLogger(String name);

		Where name is the fully qualified class name.


	Logging methods:
		
		1. debug(Object message): It is used to print the message with the level Level.DEBUG.

			Syntax:
				public void debug(Object message)

		2. error(Object message): It is used to print the message with the level Level.ERROR.
			
			Syntax:

				public void error(Object message)

		3. info(Object message): It is used to print the message with the level Level.INFO.
			
			Syntax:

				public void info(Object message)
	
		4. fatal(Object message): It is used to print the message with the level Level.FATAL.
			
			Syntax:

				public void fatal(Object message)

		5. warn(Object message): It is used to print the message with the level Level.WARN.

			Syntax:

				public void warn(Object message)

		6. trace(Object message): It is used to print the message with the level Level.TRACE.

			Syntax:

				public void trace(Object message)



							Log4j Example
						-----------------------------


		we use BasicConfigurator for Log4j configurations. 

		BasicConfigurator use ConsoleAppender and PatternLayout for all loggers.

Add the following dependency.

<dependency>  
    <groupId>log4j</groupId>  
    <artifactId>log4j</artifactId>  
    <version>1.2.17</version>  
</dependency>  

	
package com.vodafone.ui;

import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Logger;
 
public class Log4jDemo {

	// Get the Logger object.
	private static Logger log = Logger.getLogger(Log4jDemo.class);
 
	public static void main(String[] args) {

		// Configuring Log4j,It will log all messages on console.
		// BasicConfigurator use ConsoleAppender and PatternLayout 
		// for all loggers.

		BasicConfigurator.configure();
 
		// logger messages
		log.debug("it is a debug message.");
		log.info("is is an info message.");		
	}
}

Output:
-------
0 [main] DEBUG com.vodafone.ui.Log4jTest 
 - it is a debug message.
1 [main] INFO com.vodafone.ui.Log4jTest 
 - is is an info message.




								JDBC 
							      (java.sql)
							-----------------------
JDBC API	:	collection of interfaces, abstract classes.
			this is provided by sun microsystems.
			they didn't provided any implementations.

JDBC Driver	:	it is an implementation of JDBC API.
			it is provided y database vendors.
			popular jdbc driver is "Thin Driver".
			JDBC drivers are "jar" files.

5 steps:
    • Register the driver class			(from Java 8 it is optional)
    • Creating connection
    • Creating statement
    • Executing queries
    • Closing connection




mysql> use vodafonedb;
Database changed

mysql> create table employees
    -> (empno  int,
    -> ename varchar(20),
    -> salary float
    -> );


CRUD operations:
------------------
	Create			(INSERT)
	Retrieve		(SELECT)
	Update			(UPDATE)
	Delete			(DELETE)


Connection interface:

	Statement 		createStatement()
	PreparedStatement  	prepareStatement(sql)

Statement interface:
---------------------
	it is used to execute sql commands.
	it does not support parameterized query.
	it will compile the query everytime we execute. 
	we can change the sql command even before executing it.

	One statement object can be used to execute different sql commands.
	
	methods:
	--------
	1) executeUpdate(sql)		:	for INSERT / UPDATE / DELETE commands
	2) executeQuery(sql)		:	for SELECT command


PreparedStatement interface:
-------------------------------
	it is also used to execute sql commands.
	it support parameterized queries.
	it will pre-compile the query and hence execution will be faster.
	it will use only one sql command, but that can be executed for multiple times.

	1) executeUpdate();
	2) executeQuery()


	
ResultSet interface:
----------------------
	will hold the data returned from the database.


	next()	:	it will one row at a time from the result set.


_______________________________________________________________________________________________
Task:
	1. close all the resources in every program.

	2. using PreparedStatement, write program to delete an employee.

	3. using Statement, write a program to print all employees.

	4. all programs you have to show.
_______________________________________________________________________________________________





In this example we use log4j.properties file for Log4j configurations.

Example:
Log4jTest.java

import org.apache.log4j.Logger;
 
/**
 * This class is used to show the use of 
 * Log4j with the log4j.properties file.
  
 */
public class Log4jTest {
	//Get the Logger object.
	private static Logger log = Logger.getLogger(Log4jTest.class);
 
	public static void main(String[] args) {	
		//logger messages
		log.debug("Log4j debug message test.");
		log.info("Log4j info message test.");		
	}
}
log4j.properties

#log4j.rootCategory=INFO,DEBUG,A1,LFS
log4j.rootLogger=DEBUG, CA
 
#Set Console Appender
log4j.appender.CA=org.apache.log4j.ConsoleAppender
#CA uses PatternLayout
log4j.appender.CA.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%m%n
Output:
Log4j debug message test.
Log4j info message test.



Logging levels:
All logging levels are defined in the org.apache.log4j.Level class. We can also create our own levels.

Logging levels are given below:
1. ALL: All levels including custom levels also.

2. DEBUG: It helps developers in application debugging.

3. INFO: It gives the information about the progress of application and its states.

4. WARN: It gives warning for unexpected events.

5. ERROR: It provides the information about error events.

6. FATAL: It provides the information about application abort.

7. OFF: It turns off all the logging. It is opposite to the ALL level.

Standard order of all logging levels:
ALL < DEBUG < INFO < WARN < ERROR < FATAL < OFF.

i.e. If logging level set to FATAL then only FATAL messages will be displayed, if logging level set to ERROR then ERROR and FATAL messages will be displayed and so on.

In the below example as we set the logging level to WARN so only WARN, ERROR and FATAL messages will be displayed. The DEBUG and INFO message will not display.

Example:
Log4jTest.java

import org.apache.log4j.BasicConfigurator;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
 
/**
 * This class is used to show the use of 
 * logging levels in Log4j with the BasicConfigurator.
  
 */
public class Log4jTest {
	//Get the Logger object.
	private static Logger log = Logger.getLogger(Log4jTest.class);
 
	public static void main(String[] args) {
		//Configuring Log4j, It will log all messages on console.
		//BasicConfigurator use ConsoleAppender and PatternLayout 
		//for all loggers.
		BasicConfigurator.configure();
 
		//Set logging level
		log.setLevel(Level.WARN);
 
		//logger messages
		log.debug("Log4j debug message test.");
		log.info("Log4j info message test.");
		log.warn("Log4j warn message test.");
		log.error("Log4j error message test.");
		log.fatal("Log4j fatal message test.");
	}
}
Output:
0 [main] WARN com.w3spoint.business.Log4jTest 
 - Log4j warn message test.
1 [main] ERROR com.w3spoint.business.Log4jTest 
 - Log4j error message test.
1 [main] FATAL com.w3spoint.business.Log4jTest 
 - Log4j fatal message test.



Log4j File Appender

Log4jTest.java

import org.apache.log4j.Logger;
 
/**
 * This class is used to show the use of 
 * file appender with the log4j.properties file.
  
 */
public class Log4jTest {
	//Get the Logger object.
	private static Logger log = Logger.getLogger(Log4jTest.class);
 
	public static void main(String[] args) {	
		//logger messages
		log.debug("Log4j debug message test.");
		log.info("Log4j info message test.");
		log.warn("Log4j warn message test.");
		log.error("Log4j error message test.");
		log.fatal("Log4j fatal message test.");		
	}
}
log4j.properties

#log4j.rootCategory=INFO,DEBUG,A1,LFS,FA,CA
log4j.rootLogger=DEBUG, FA
 
#Set File Appender
log4j.appender.FA=org.apache.log4j.FileAppender
log4j.appender.FA.File=test.log
#Set FA Layout
log4j.appender.FA.layout=org.apache.log4j.PatternLayout
log4j.appender.FA.layout.ConversionPattern=%m%n
Output:
Log4j debug message test.
Log4j info message test.
Log4j warn message test.
Log4j error message test.
Log4j fatal message test.


Log4j Multiple Appenders

Log4jTest.java

import org.apache.log4j.Logger;
 
/**
 * This class is used to show the use of 
 * multiple appenders with the log4j.properties file.
  
 */
public class Log4jTest {
	//Get the Logger object.
	private static Logger log = Logger.getLogger(Log4jTest.class);
 
	public static void main(String[] args) {	
		//logger messages
		log.debug("Log4j debug message test.");
		log.info("Log4j info message test.");
		log.warn("Log4j warn message test.");
		log.error("Log4j error message test.");
		log.fatal("Log4j fatal message test.");		
	}
}
log4j.properties

#log4j.rootCategory=INFO,DEBUG,A1,LFS,FA,CA
log4j.rootLogger=DEBUG, CA, FA
 
#Set Console Appender
log4j.appender.CA=org.apache.log4j.ConsoleAppender
#Set CA Layout
log4j.appender.CA.layout=org.apache.log4j.PatternLayout
log4j.appender.A1.layout.ConversionPattern=%m%n
 
#Set File Appender
log4j.appender.FA=org.apache.log4j.FileAppender
log4j.appender.FA.File=test.log
#Set FA Layout
log4j.appender.FA.layout=org.apache.log4j.PatternLayout
log4j.appender.FA.layout.ConversionPattern=%m%n
 
#Set the logging level of FA to WARN
log4j.appender.FA.Threshold = WARN
Output:
Console

Log4j debug message test.
Log4j info message test.
Log4j warn message test.
Log4j error message test.
Log4j fatal message test.
test.log

Log4j warn message test.
Log4j error message test.
Log4j fatal message test.



		

Best Practices in Java Coding:
-------------------------------
1. Using Naming Conventions:

	a) When naming identifiers (methods, classes, and variables), it's a good practice for you to let the respective things you name them 	   with to be self-explanatory, distinct, and pronounceable.
	b) Most importantly, you must always ensure to write readable codes that are easily understood by humans.
	3) Not just write codes for the sake of satisfying the compiler.
	
2. Ordering Class Members by Scopes:

 	a) private, default (package), protected, and public. 
	b) And a blank line separates each of the groups. 
	c) it would be nice of you to sort each member by the visibility of the access modifiers

3. Class Members should be private.

	a) The only logical reason for practicing this is to bring out the usefulness of encapsulating information

4. Using Underscores in Numeric Literals

	a) Before using Underscore:

		int minUploadSize = 05437326;
		long debitBalance = 5000000000000000L;
		float pi = 3.141592653589F;

	b) After making use of Underscore:

		int minUploadSize = 05_437_326;
		long debitBalance = 5_000_000_000_000_000L;
		float pi = 3.141_592_653_589F;

5. Avoid Redundant Initialization (0-false-null)

	a) the following initialization is not recommended.

		public class Person {
   			private String name = null;
   			private int age = 0;
   			private boolean isGenius = false;
		}

	b) why?
		since null and 0 and false are the default initial values for String, int and boolean types.



Worst Practices When Coding in Java:
------------------------------------

1. Neglecting Existing Libraries

	a) for example observe the following code.

		double areaOfCircle = 3.14 * radius * radius;

	b) instead use the Math.PI

		double areaOfCircle = Math.PI * radius * radius;



2. Using Raw Type Instead of a Parameterized One

	a) Raw Collection - Not TypeSafe - and - Heterogeneous.

		List listOfNumbers = new ArrayList();
		listOfNumbers.add(20);
		listOfNumbers.add("Forty");
		listOfNumbers.forEach(n -> System.out.println((int) n * 2));



	b) Making it as Generic Collection - TypeSafe.

		ArrayList<Integer> list = new ArrayList<>();
		list.add(20);
		
		list.add("Forty")			// compilation error

3. Exceptions

	a) Don't handle Unchecked exceptions. 
	   Instead we have to use "defensive programming" to avoid unchecked exceptions.

	b) Anyway, you have to handle checked exceptions.
	

4. Excessive Garbage Allocation

	a) Creating many short-lived objects may result in excessive garbage allocation. 
	   the performance of an application is affected negatively anytime the garbage collector tries to remove an unneeded object from 
           memory.


		class ReverseString {
			public static void main(String[] args) {
				String str = "java";
				String revString = "";

				for(int i = str.length() - 1; i >= 0; i--) {
					revString += str.charAt(i);
				}

				System.out.println("Reverse String = " + revString);
			}
		}

		
		The above create many temporary String objects.

	
	b) The alternate is use StringBuilder instead. It is a mutable class.

		class ReverseStringUsingStringBuilder {
			public static void main(String[] args) {
				String str = "java";
				StringBuilder revString = new StringBuilder();

				for(int i = str.length() - 1; i >= 0; i--) {
					revString.append(str.charAt(i));
				}

				System.out.println("Reverse String = " + revString);
			}
		}


		
==========================
DAY 5 
==========================


							MVC
						----------------------
	MVC stands for "Model View Controller".
	It is a design pattern.

	Model			:	It holds the data.
					model is a java class.
	View			:	It represent presentation.
					If it is a web application, using html pages.
	Controller		:	which will take care of the flow of an entire application and
					also responsible for request-response mechansism.

	To make use of MVC architecture:
		Spring			:	Spring Web MVC
		Spring Boot		:	Spring Boot Web MVC



							Design Patterns
					--------------------------------------------
	these proposed methodologies to solve a particular problem.

	1. creational design patterns
		singleton design pattern : if any class contain only one object for an entire application.
					  eg: 	create a class and write a utility method to call
						database connection.
						
					   eg:
						DatabaseUtil.getConnection()
	2. structural design patterns
	3. behavioural design patterns.




    • TDD 
    • Understanding Test Cases 
    • Using Junit for Unit test 
    • Understanding Test Suites 

    • Multithread Introduction 
    • Creating Threads with Extends/implements 
    • Thread Life Cycle 
    • Thread Synchronization 
    • Inter Thread Communication 
    • Deadlock Concept 

    • File Handling 
    • Serialization Concept 
    • Java Stream Concept 
    • Byte Stream 
    • Character Stream


		1) BDD		(Behavioural driven development)  approach

					develop the code.
					test the code.

		2) TDD		(Test Driven development) approach

					test cases (testing code) developed.
					we use junit, which is a testing framework.
					developers will take the test cases, and write their code such a way that
					it passes all test cases.


		class under test :	it is the class given by the developer
					for which a test has to write code to check the validity of the code.


		test class	:	it is a collection of methods also known as "Test Cases".
					it is written by a tester.
					this is where we use junit 5.


		@Test		:	it is the method level annotation indicate a test case.

		@BeforeEach	:	it a method that is executed before every test.
					these are also known as setup methods.

		@AfterEach	:	it is a method that is executed after every test.
					this is als known as teardown method.

		@BeforeAll	:	it is executed only once before running any test case.
		@AfterAll	:	it is executed only once after running all test case.

		Assertions	:	Assertions is a collection of utility methods 
					that support asserting conditions in tests. 


					 assertEquals()
					 assertNotEquals()
					 assertTrue()
					 assertFalse()
					 assertArrayEquals()
					 assertArrayNotEquals()
					 assertNull()
					 assertNotNull()

		@DisplayName(value = "meaning full name")
		@Disabled


		TestSuite	:	collection related test classes.



			
						Multi Threading
					-----------------------------------

Thread is a separate path of execution.


thread can be created in 2 ways.
i) extending java.lang.Thread  class
ii) implementing java.lang.Runnable interface


Thread life cycle methods:
----------------------------
1) start()
2) stop()
3) run()	: contain the code that is associated with the thread.
		  as and when we use threadObject.start(), it invoke the run() method.\\\


Thread class method:
---------------------
4) sleep(milli-seconds)
5) setName(string)

	synchronization:

			a method
			a block

	only when we want to share an object across multiple threads.





							IOStreams
							(java.io)
						------------------------------
Store data permanantly.	(persistence)


java.lang	package		(default package)
	System
	String
	Math
	Object
	
java.util	package
	Scanner
	Collection API

java.io		package

stream : flow of data.


File class:
	it is used to convert a physical file into a java object.
		
1) character streams	(text streams)	:	to store/retrieve unstructured information.

	Reader abstract class
		FileReader class
		BufferedReader class
	Writer abstract class
		FileWriter class
			write(string)
		PrintWriter class

2) byte streams	(binary streams) :		to store objects, images, audio, video etc.,

	InputStream abstract class
		FileInputStream class
		ObjectInputStream class
	OutputStream abstract class
		FileOutputStream class		
		ObjectOutputStream class	

	serialization:
		it is the process of converting object data into binary form.
		this process is known as serialization.

	de-serialization
		it is the process of converting binary data back to object form.
		this process is known as deserialization.

	_______________________________________________________________________________
	Rule:
		to perform the serialization our model class must be inherited from 
		java.io.Serializable interface.


		Serializable interface doesnot contain any abstract methods.
		It is a null interface.
		It is only act like marker interface for a class.
	______________________________________________________________________________




















 
1. abhishek kamble			
2. ajay shedge
3. ankush nagarnaik			
4. devyani umale			
5. dhruva kale
6. harshada memane			
7. ketan kulkarni			
8. khaled Barbhuiya
9. mayank khurade			
10. mayuri shinde			
11. naga lakshmi padma 			
12. nisha jagtap			
13. nisha pharande
14. Pranali Raipure
15. pravin shende	
16. preeti tiwari				
17. priti ekhande			
18. samrudhi haral			
19. satyam prasad deva sarmah	
20. sevak singh bhatia			
21. shubham raut	
22. shorya goyal						
23. shruthika raikwad			
24. Soham Gugalgawe	
25. Tanvi Borade				
26. Vaibhav Mane			
			



				
		


		